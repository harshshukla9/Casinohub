/**
 * Provable Fair System for Mines Game
 * 
 * This implementation uses a client-server seed system where:
 * - Server seed: Generated by the server (kept secret until game ends)
 * - Client seed: Provided by the user (or auto-generated)
 * - Combined seed: SHA256(serverSeed + clientSeed)
 * - Game state is deterministically generated from the combined seed
 * - Hash is computed from game state before revealing tiles
 */

// Convert string to array of bytes
function stringToBytes(str: string): Uint8Array {
  return new TextEncoder().encode(str);
}

// Convert bytes to hex string
function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

// Convert hex string to bytes
function hexToBytes(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
  }
  return bytes;
}

// SHA256 hash function (using Web Crypto API)
export async function sha256(data: string | Uint8Array): Promise<string> {
  let dataBytes: Uint8Array;
  if (typeof data === 'string') {
    dataBytes = stringToBytes(data);
  } else {
    dataBytes = data;
  }
  // Create a new ArrayBuffer to ensure compatibility
  const buffer = new Uint8Array(dataBytes).buffer;
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = new Uint8Array(hashBuffer);
  return bytesToHex(hashArray);
}

// Generate a random seed (for client seed generation)
export function generateRandomSeed(): string {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return bytesToHex(array);
}

// Combine server and client seeds
export async function combineSeeds(serverSeed: string, clientSeed: string): Promise<string> {
  return await sha256(serverSeed + clientSeed);
}

// Seeded PRNG (Pseudo-Random Number Generator) for deterministic generation
class SeededPRNG {
  private seed: number;

  constructor(seed: string) {
    // Convert seed string to number
    let hash = 0;
    for (let i = 0; i < seed.length; i++) {
      const char = seed.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    this.seed = Math.abs(hash) || 1;
  }

  // Generate next random number between 0 and 1
  next(): number {
    this.seed = (this.seed * 9301 + 49297) % 233280;
    return this.seed / 233280;
  }

  // Generate random integer between min (inclusive) and max (exclusive)
  nextInt(min: number, max: number): number {
    return Math.floor(this.next() * (max - min)) + min;
  }
}

// Generate mine positions deterministically from seed
export function generateMinePositions(
  seed: string,
  mineCount: number,
  totalTiles: number
): number[] {
  const positions: number[] = [];
  const used = new Set<number>();
  const prng = new SeededPRNG(seed);
  
  while (positions.length < mineCount && positions.length < totalTiles) {
    const position = prng.nextInt(0, totalTiles);
    
    if (!used.has(position)) {
      used.add(position);
      positions.push(position);
    }
    
    // Safety check to prevent infinite loop
    if (used.size >= totalTiles) break;
  }
  
  return positions.sort((a, b) => a - b);
}

// Generate game state hash
export async function generateGameHash(gameState: {
  minePositions: number[];
  mineCount: number;
  totalTiles: number;
  mode: string;
  betAmount: number;
  serverSeed: string;
  clientSeed: string;
}): Promise<string> {
  // Create a deterministic string representation of the game state
  const stateString = JSON.stringify({
    minePositions: gameState.minePositions.sort((a, b) => a - b),
    mineCount: gameState.mineCount,
    totalTiles: gameState.totalTiles,
    mode: gameState.mode,
    betAmount: gameState.betAmount,
    serverSeed: gameState.serverSeed,
    clientSeed: gameState.clientSeed,
  });
  
  return await sha256(stateString);
}

// Reconstruct game state from seeds (for verification)
export async function reconstructGameState(
  serverSeed: string,
  clientSeed: string,
  mineCount: number,
  totalTiles: number,
  mode: string,
  betAmount: number
): Promise<{
  minePositions: number[];
  combinedSeed: string;
  gameHash: string;
}> {
  const combinedSeed = await combineSeeds(serverSeed, clientSeed);
  const minePositions = generateMinePositions(combinedSeed, mineCount, totalTiles);
  
  const gameHash = await generateGameHash({
    minePositions,
    mineCount,
    totalTiles,
    mode,
    betAmount,
    serverSeed,
    clientSeed,
  });
  
  return {
    minePositions,
    combinedSeed,
    gameHash,
  };
}

// Verify game hash
export async function verifyGameHash(
  expectedHash: string,
  serverSeed: string,
  clientSeed: string,
  mineCount: number,
  totalTiles: number,
  mode: string,
  betAmount: number
): Promise<{
  isValid: boolean;
  minePositions: number[];
  computedHash: string;
}> {
  const reconstructed = await reconstructGameState(
    serverSeed,
    clientSeed,
    mineCount,
    totalTiles,
    mode,
    betAmount
  );
  
  return {
    isValid: reconstructed.gameHash === expectedHash,
    minePositions: reconstructed.minePositions,
    computedHash: reconstructed.gameHash,
  };
}

